{
  "hash": "3dd622204712c655fb098de7d297c426",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"In-class Exercise 2: Spatial Point Patterns Analysis: spatstat methods\"\nauthor: \"Dr. Kam Tin Seong\"\ndate: \"2025-07-21\"\nformat: \n  revealjs:\n    width: 1600\n    height: 900\n    show-notes: false\n    slide-number: true\n    show-slide-number: all\nexecute: \n  eval: true\n  echo: true\n  message: false\n  freeze: true\ndate-format: \"DD MMM YYYY\"\n---\n\n## Issue 1: Installing maptools\n\n**maptools** is retired and binary is removed from CRAN. However, we can download from [Posit Public Package Manager](https://packagemanager.posit.co/client/#/repos/cran/setup?snapshot=2023-10-13&distribution=windows&r_environment=ide) snapshots by using the code chunk below.\n\n::: {style=\"font-size: 1.50em\"}\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"maptools\", \n                 repos = \"https://packagemanager.posit.co/cran/2023-10-13\")\n```\n:::\n\n:::\n\n## Issue 1: Installing maptools\n\n::: columns\n::: {.column width=\"65%\"}\nAfter the installation is completed, it is important to edit the code chunk as shown below in order to avoid **maptools** being download and install repetitively every time the Quarto document been rendered.\n\n![](img/image1.jpg)\n\n\n::: {.cell}\n\n:::\n\n:::\n:::\n\n## Issue 2: Creating coastal outline\n\n\n::: {.cell}\n\n:::\n\n\nIn **sf** package, there are two functions allow us to combine multiple simple features into one simple features. They are [`st_combine()`](https://r-spatial.github.io/sf/reference/geos_combine.html) and `st_union()`.\n\n-   `st_combine()` returns a single, combined geometry, with no resolved boundaries; returned geometries may well be invalid.\n\n-   If y is missing, `st_union(x)` returns a single geometry with resolved boundaries, else the geometries for all unioned pairs of x\\[i\\] and y\\[j\\].\n\n------------------------------------------------------------------------\n\n### Working with `st_union()`\n\n::: columns\n::: {.column width=\"65%\"}\nThe code chunk below, `st_union()`is used to derive the coastal outline sf tibble data.frame.\n\n::: {style=\"font-size: 1.50em\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nsg_sf <- mpsz_sf %>%\n  st_union()\n```\n:::\n\n:::\n\n*sg_sf* will look similar to the figure below.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](In-class_Ex02-SPPA_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n:::\n:::\n\n## Introducing spatstat package\n\n[**spatstat**](https://spatstat.org/) R package is a comprehensive open-source toolbox for analysing Spatial Point Patterns. Focused mainly on two-dimensional point patterns, including multitype or marked points, in any spatial region.\n\n## spatstat\n\n### spatstat sub-packages\n\n::: {style=\"font-size: 0.75em\"}\n-   The [**spatstat**](https://cran.r-project.org/web/packages/spatstat/index.html) package now contains only documentation and introductory material. It provides beginnerâ€™s introductions, vignettes, interactive demonstration scripts, and a few help files summarising the package.\n-   The [**spatstat.data**]() package now contains all the datasets for spatstat.\n-   The [**spatstat.utils**](https://cran.r-project.org/web/packages/spatstat.utils/index.html) package contains basic utility functions for spatstat.\n-   The [**spatstat.univar**](https://cran.r-project.org/web/packages/spatstat.univar/spatstat.univar.pdf) package contains functions for estimating and manipulating probability distributions of one-dimensional random variables.\n-   The [**spatstat.sparse**](https://cran.r-project.org/web/packages/spatstat.sparse/spatstat.sparse.pdf) package contains functions for manipulating sparse arrays and performing linear algebra.\n-   The [**spatstat.geom**](https://cran.r-project.org/web/packages/spatstat.geom/index.html) package contains definitions of spatial objects (such as point patterns, windows and pixel images) and code which performs geometrical operations.\n-   The [**spatstat.random**](https://cran.r-project.org/web/packages/spatstat.random/index.html) package contains functions for random generation of spatial patterns and random simulation of models.\n-   The [**spatstat.explore**](https://cran.r-project.org/web/packages/spatstat.explore/index.html) package contains the code for exploratory data analysis and nonparametric analysis of spatial data.\n-   The [**spatstat.model**](https://cran.r-project.org/web/packages/spatstat.model/index.html) package contains the code for model-fitting, model diagnostics, and formal inference.\n-   The [**spatstat.linnet**](https://cran.r-project.org/web/packages/spatstat.linnet/index.html) package defines spatial data on a linear network, and performs geometrical operations and statistical analysis on such data.\n:::\n\n## Creating ppp objects from sf data.frame\n\nInstead of using the two steps approaches discussed in Hands-on Exercise 3 to create the **ppp** objects, in this section you will learn how to work with sf data.frame.\n\n::: columns\n::: {.column width=\"50%\"}\nIn the code chunk below, [`as.ppp()`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/as.ppp.html) of [**spatstat.geom**](https://cran.r-project.org/web/packages/spatstat.geom/spatstat.geom.pdf) package is used to derive an **ppp** object layer directly from a sf tibble data.frame.\n\n::: {style=\"font-size: 1.50em\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nchildcare_ppp <- as.ppp(childcare_sf)\nplot(childcare_ppp)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in default.charmap(ntypes, chars): Too many types to display every type\nas a different character\nWarning in default.charmap(ntypes, chars): Too many types to display every type\nas a different character\nWarning in default.charmap(ntypes, chars): Too many types to display every type\nas a different character\nWarning in default.charmap(ntypes, chars): Too many types to display every type\nas a different character\nWarning in default.charmap(ntypes, chars): Too many types to display every type\nas a different character\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Only 10 out of 1925 symbols are shown in the symbol map\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in default.charmap(ntypes, chars): Too many types to display every type\nas a different character\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Only 10 out of 1925 symbols are shown in the symbol map\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](In-class_Ex02-SPPA_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n:::\n:::\n\n::: {.column width=\"50%\"}\nNext, `summary()` can be used to reveal the properties of the newly created ppp objects.\n\n::: {style=\"font-size: 1.50em\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(childcare_ppp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMarked planar point pattern:  1925 points\nAverage intensity 2.417323e-06 points per square unit\n\nCoordinates are given to 11 decimal places\n\nMark variables: Name, Description\nSummary:\n     Name           Description       \n Length:1925        Length:1925       \n Class :character   Class :character  \n Mode  :character   Mode  :character  \n\nWindow: rectangle = [11810.03, 45404.24] x [25596.33, 49300.88] units\n                    (33590 x 23700 units)\nWindow area = 796335000 square units\n```\n\n\n:::\n:::\n\n:::\n:::\n:::\n\n## Creating ***owin*** object from sf data.frame\n\n::: columns\n::: {.column width=\"50%\"}\nIn the code chunk `as.owin()` of **spatstat.geom** is used to create an **owin** object class from polygon sf tibble data.frame.\n\n::: {style=\"font-size: 1.50em\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nsg_owin <- as.owin(sg_sf)\nplot(sg_owin)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex02-SPPA_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n:::\n:::\n\n::: {.column width=\"50%\"}\nNext, *summary()* function is used to display the summary information of the owin object class.\n\n::: {style=\"font-size: 1.50em\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(sg_owin)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nWindow: polygonal boundary\n80 separate polygons (35 holes)\n                  vertices         area relative.area\npolygon 1            14650  6.97996e+08      8.93e-01\npolygon 2 (hole)         3 -2.21090e+00     -2.83e-09\npolygon 3              285  1.61128e+06      2.06e-03\npolygon 4 (hole)         3 -2.05920e-03     -2.63e-12\npolygon 5 (hole)         3 -8.83647e-03     -1.13e-11\npolygon 6              668  5.40368e+07      6.91e-02\npolygon 7               44  2.26577e+03      2.90e-06\npolygon 8               27  1.50315e+04      1.92e-05\npolygon 9              711  1.28815e+07      1.65e-02\npolygon 10 (hole)       36 -4.01660e+04     -5.14e-05\npolygon 11 (hole)      317 -5.11280e+04     -6.54e-05\npolygon 12 (hole)        3 -3.41405e-01     -4.37e-10\npolygon 13 (hole)        3 -2.89050e-05     -3.70e-14\npolygon 14              77  3.29939e+05      4.22e-04\npolygon 15              30  2.80002e+04      3.58e-05\npolygon 16 (hole)        3 -2.83151e-01     -3.62e-10\npolygon 17              71  8.18750e+03      1.05e-05\npolygon 18 (hole)        3 -1.68316e-04     -2.15e-13\npolygon 19 (hole)       36 -7.79904e+03     -9.97e-06\npolygon 20 (hole)        4 -2.05611e-02     -2.63e-11\npolygon 21 (hole)        3 -2.18000e-06     -2.79e-15\npolygon 22 (hole)        3 -3.65501e-03     -4.67e-12\npolygon 23 (hole)        3 -4.95057e-02     -6.33e-11\npolygon 24 (hole)        3 -3.99521e-02     -5.11e-11\npolygon 25 (hole)        3 -6.62377e-01     -8.47e-10\npolygon 26 (hole)        3 -2.09065e-03     -2.67e-12\npolygon 27              91  1.49663e+04      1.91e-05\npolygon 28 (hole)       26 -1.25665e+03     -1.61e-06\npolygon 29 (hole)      349 -1.21433e+03     -1.55e-06\npolygon 30 (hole)       20 -4.39069e+00     -5.62e-09\npolygon 31 (hole)       48 -1.38338e+02     -1.77e-07\npolygon 32 (hole)       28 -1.99862e+01     -2.56e-08\npolygon 33              40  1.38607e+04      1.77e-05\npolygon 34 (hole)       40 -6.00381e+03     -7.68e-06\npolygon 35 (hole)        7 -1.40545e-01     -1.80e-10\npolygon 36 (hole)       12 -8.36709e+01     -1.07e-07\npolygon 37              45  2.51218e+03      3.21e-06\npolygon 38             142  3.22293e+03      4.12e-06\npolygon 39             148  3.10395e+03      3.97e-06\npolygon 40              75  1.73526e+04      2.22e-05\npolygon 41              83  5.28920e+03      6.76e-06\npolygon 42             211  4.70521e+05      6.02e-04\npolygon 43             106  3.04104e+03      3.89e-06\npolygon 44             266  1.50631e+06      1.93e-03\npolygon 45              71  5.63061e+03      7.20e-06\npolygon 46              10  1.99717e+02      2.55e-07\npolygon 47             478  2.06120e+06      2.64e-03\npolygon 48             155  2.67502e+05      3.42e-04\npolygon 49            1027  1.27782e+06      1.63e-03\npolygon 50 (hole)        3 -1.16959e-03     -1.50e-12\npolygon 51              65  8.42861e+04      1.08e-04\npolygon 52              47  3.82087e+04      4.89e-05\npolygon 53               6  4.50259e+02      5.76e-07\npolygon 54             132  9.53357e+04      1.22e-04\npolygon 55 (hole)        3 -3.23310e-04     -4.13e-13\npolygon 56               4  2.69313e+02      3.44e-07\npolygon 57 (hole)        3 -1.46474e-03     -1.87e-12\npolygon 58            1045  4.44510e+06      5.68e-03\npolygon 59              22  6.74651e+03      8.63e-06\npolygon 60              64  3.43149e+04      4.39e-05\npolygon 61 (hole)        3 -1.98390e-03     -2.54e-12\npolygon 62 (hole)        4 -1.13774e-02     -1.46e-11\npolygon 63              14  5.86546e+03      7.50e-06\npolygon 64              95  5.96187e+04      7.62e-05\npolygon 65 (hole)        4 -1.86410e-02     -2.38e-11\npolygon 66 (hole)        3 -5.12482e-03     -6.55e-12\npolygon 67 (hole)        3 -1.96410e-03     -2.51e-12\npolygon 68 (hole)        3 -5.55856e-03     -7.11e-12\npolygon 69             234  2.08755e+06      2.67e-03\npolygon 70              10  4.90942e+02      6.28e-07\npolygon 71             234  4.72886e+05      6.05e-04\npolygon 72 (hole)       13 -3.91907e+02     -5.01e-07\npolygon 73              15  4.03300e+04      5.16e-05\npolygon 74             227  1.10308e+06      1.41e-03\npolygon 75              10  6.60195e+03      8.44e-06\npolygon 76              19  3.09221e+04      3.95e-05\npolygon 77             145  9.61782e+05      1.23e-03\npolygon 78              30  4.28933e+03      5.49e-06\npolygon 79              37  1.29481e+04      1.66e-05\npolygon 80               4  9.47108e+01      1.21e-07\nenclosing rectangle: [2667.54, 56396.44] x [15748.72, 50256.33] units\n                     (53730 x 34510 units)\nWindow area = 781945000 square units\nFraction of frame area: 0.422\n```\n\n\n:::\n:::\n\n:::\n:::\n:::\n\n## Combining point events object and owin object\n\n::: panel-tabset\n### The task\n\nUsing the step you learned from Hands-on Exercise 3, create an ppp object by combining childcare_ppp and sg_owin.\n\n### The code\n\n::: {style=\"font-size: 1.50em\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nchildcareSG_ppp = childcare_ppp[sg_owin]\n```\n:::\n\n:::\n\n### The output\n\nThe output object combined both the point and polygon feature in one ppp object class as shown below.\n\n::: {style=\"font-size: 1.50em\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(childcareSG_ppp)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in default.charmap(ntypes, chars): Too many types to display every type\nas a different character\nWarning in default.charmap(ntypes, chars): Too many types to display every type\nas a different character\nWarning in default.charmap(ntypes, chars): Too many types to display every type\nas a different character\nWarning in default.charmap(ntypes, chars): Too many types to display every type\nas a different character\nWarning in default.charmap(ntypes, chars): Too many types to display every type\nas a different character\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Only 10 out of 1925 symbols are shown in the symbol map\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in default.charmap(ntypes, chars): Too many types to display every type\nas a different character\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Only 10 out of 1925 symbols are shown in the symbol map\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](In-class_Ex02-SPPA_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n:::\n:::\n\n## Kernel Density Estimation of Spatial Point Event\n\nThe code chunk below re-scale the unit of measurement from metre to kilometre before performing KDE.\n\n::: {style=\"font-size: 1.50em\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nchildcareSG_ppp.km <- rescale.ppp(childcareSG_ppp, \n                                  1000, \n                                  \"km\")\n\nkde_childcareSG_adaptive <- adaptive.density(\n  childcareSG_ppp.km, \n  method=\"kernel\")\nplot(kde_childcareSG_adaptive)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex02-SPPA_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n:::\n\n## Kernel Density Estimation\n\nCode chunk shown two different ways to convert KDE output into grid object\n\n::: panel-tabset\n### maptools method\n\n::: {style=\"font-size: 1.50em\"}\n\n::: {.cell}\n\n```{.r .cell-code}\npar(bg = '#E4D5C9')\n\ngridded_kde_childcareSG_ad <- maptools::as.SpatialGridDataFrame.im(\n  kde_childcareSG_adaptive)\nspplot(gridded_kde_childcareSG_ad)\n```\n:::\n\n:::\n\n### spatstat.geom method\n\n::: {style=\"font-size: 1.50em\"}\n\n::: {.cell}\n\n```{.r .cell-code}\ngridded_kde_childcareSG_ad <- as(\n  kde_childcareSG_adaptive,\n  \"SpatialGridDataFrame\")\nspplot(gridded_kde_childcareSG_ad)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex02-SPPA_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n:::\n:::\n\n## Kernel Density Estimation\n\n### Visualising KDE using tmap\n\n\n::: {.cell}\n\n:::\n\n\nThe code chunk below is used to plot the output raster by using tmap functions.\n\n::: {style=\"font-size: 1.50em\"}\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(kde_childcareSG_ad_raster) + \n  tm_raster(palette = \"viridis\") +\n  tm_layout(legend.position = c(\"right\", \"bottom\"), \n            frame = FALSE,\n            bg.color = \"#E4D5C9\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nâ”€â”€ tmap v3 code detected â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n[v3->v4] `tm_tm_raster()`: migrate the argument(s) related to the scale of the\nvisual variable `col` namely 'palette' (rename to 'values') to col.scale =\ntm_scale(<HERE>).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](In-class_Ex02-SPPA_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n:::\n\n## Extracting study area using sf objects\n\n::: panel-tabset\n### The task\n\nExtract and create an ppp object showing child care services and within Punggol Planning Area\n\n### The code\n\nOn the other hand, `filter()` of dplyr package should be used to extract the target planning areas as shown in the code chunk below.\n\n::: {style=\"font-size: 1.50em\"}\n\n::: {.cell}\n\n```{.r .cell-code}\npg_owin <- mpsz_sf %>%\n  filter(PLN_AREA_N == \"PUNGGOL\") %>%\n  as.owin()\n\nchildcare_pg = childcare_ppp[pg_owin]\n\nplot(childcare_pg)  \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in default.charmap(ntypes, chars): Too many types to display every type\nas a different character\nWarning in default.charmap(ntypes, chars): Too many types to display every type\nas a different character\nWarning in default.charmap(ntypes, chars): Too many types to display every type\nas a different character\nWarning in default.charmap(ntypes, chars): Too many types to display every type\nas a different character\nWarning in default.charmap(ntypes, chars): Too many types to display every type\nas a different character\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Only 10 out of 72 symbols are shown in the symbol map\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in default.charmap(ntypes, chars): Too many types to display every type\nas a different character\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Only 10 out of 72 symbols are shown in the symbol map\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](In-class_Ex02-SPPA_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n:::\n:::\n\n## Monte Carlo Simulation\n\n::: columns\n::: {.column width=\"50%\"}\n::: callout-tip\nIn order to ensure reproducibility, it is important to include the code chunk below before using spatstat functions involve Monte Carlo simulation\n:::\n\n::: {style=\"font-size: 1.50em\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\n```\n:::\n\n:::\n:::\n:::\n\n## Edge correction methods of spatstat\n\nIn spatstat, edge correction methods are used to handle biases that arise when estimating spatial statistics near the boundaries of a study region. These corrections are essential for ensuring accurate estimates in spatial point pattern analysis, especially for summary statistics like the K-function, L-function, pair correlation function, etc.\n\n::: {style=\"font-size: 0.75em\"}\nCommon Edge Correction Methods in spatstat\n\n- \"none\": No edge correction is applied. This method assumes that there is no bias at the edges, which may lead to underestimation of statistics near the boundaries.\n-   \"isotropic\": This method corrects for edge effects by assuming that the point pattern is isotropic (uniform in all directions). It compensates for missing neighbors outside the boundary by adjusting the distances accordingly.\n-   \"translate\" (Translation Correction): This method uses a translation correction, which involves translating the observation window so that every point lies entirely within it. The statistic is then averaged over all possible translations.\n-   \"Ripley\" (Ripleyâ€™s Correction): Similar to the isotropic correction but specifically tailored for Ripleyâ€™s K-function and related functions. It adjusts the expected number of neighbors for points near the edges based on the shape and size of the observation window.\n-   \"border\": Border correction reduces bias by only considering points far enough from the boundary so that their neighborhood is fully contained within the window. This can be quite conservative but reduces the influence of edge effects.\n:::\n\n## Geospatial Analytics for Social Good: Thailand Road Accident Case Study\n\n### Background\n\n-   [Road traffic injuries](https://www.who.int/news-room/fact-sheets/detail/road-traffic-injuries), WHO.\n-   [Road traffic deaths and injuries in Thailand](https://cdn.who.int/media/docs/default-source/thailand/roadsafety/overview-en-final-25-7-19.pdf?sfvrsn=f9d7a862_2)\n\n## The Study Area\n\nThe study area is [Bangkok Metropolitan Region](https://en.wikipedia.org/wiki/Bangkok_Metropolitan_Region).\n\n![](img/BMR.png)\n\n::: callout-note\nThe projected coordinate system of Thailand is **WGS 84 / UTM zone 47N** and the EPSG code is [32647](https://epsg.io/32647).\n:::\n\n## The Data\n\nFor the purpose of this exercise, three basic data sets are needed, they are:\n\n-   [Thailand Road Accident \\[2019-2022\\]](https://www.kaggle.com/datasets/thaweewatboy/thailand-road-accident-2019-2022) on Kaggle\n\n-   [Thailand Roads (OpenStreetMap Export)](https://data.humdata.org/dataset/hotosm_tha_roads) on HDX.\n\n-   [Thailand - Subnational Administrative Boundaries](https://data.humdata.org/dataset/cod-ab-tha?) on HDX.\n\n## Importing Traffic Accident Data\n\n::: panel-tabset\n### The task\n\nUsing the steps you learned in previous lessons, import the downloaded accident data into R environment and save the output as an sf tibble data.frame.\n\n### The code\n\n::: {style=\"font-size: 1.50em\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nrdacc_sf <- read_csv(\"data/thai_road_accident_2019_2022.csv\") %>%\n  filter(!is.na(longitude) & longitude != \"\", \n         !is.na(latitude) & latitude != \"\") %>%\n  st_as_sf(coords = c(\n    \"longitude\", \"latitude\"),\n    crs=4326) %>%\n  st_transform(crs = 32647) \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 81735 Columns: 18\nâ”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nDelimiter: \",\"\nchr  (10): province_th, province_en, agency, route, vehicle_type, presumed_c...\ndbl   (6): acc_code, number_of_vehicles_involved, number_of_fatalities, numb...\ndttm  (2): incident_datetime, report_datetime\n\nâ„¹ Use `spec()` to retrieve the full column specification for this data.\nâ„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n:::\n:::\n\n## Visualising The Accident Data\n\n::: panel-tabset\n### The task\n\nUsing the steps you learned in previous lessons, import the ACLED data into R environment as an sf tibble data.frame.\n\n### The code\n\n::: {style=\"font-size: 1.50em\"}\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\nacled_sf %>%\n  filter(year == 2023 | \n           event_type == \"Political violence\") %>%\n  tm_shape()+\n  tm_dots()\ntmap_mode(\"plot\")\n```\n:::\n\n:::\n:::\n",
    "supporting": [
      "In-class_Ex02-SPPA_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}